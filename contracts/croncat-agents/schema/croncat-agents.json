{
  "contract_name": "croncat-agents",
  "contract_version": "0.1.1",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "croncat_manager_key",
      "croncat_tasks_key"
    ],
    "properties": {
      "agent_nomination_duration": {
        "description": "Sets the amount of time opportunity for a pending agent to become active. If there is a pending queue, the longer a pending agent waits, the more pending agents can potentially become active based on this nomination window. This duration doesn't block the already nominated agent from becoming active, it only opens the door for more to become active. If a pending agent is nominated, then is lazy and beat by another agent, they get removed from pending queue and must register again.",
        "type": [
          "integer",
          "null"
        ],
        "format": "uint16",
        "minimum": 0.0
      },
      "agents_eject_threshold": {
        "description": "How many slots an agent can miss before being removed from the active queue",
        "type": [
          "integer",
          "null"
        ],
        "format": "uint64",
        "minimum": 0.0
      },
      "croncat_manager_key": {
        "description": "Name of the key for raw querying Manager address from the factory",
        "type": "array",
        "items": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint8",
              "minimum": 0.0
            },
            "maxItems": 2,
            "minItems": 2
          }
        ],
        "maxItems": 2,
        "minItems": 2
      },
      "croncat_tasks_key": {
        "description": "Name of the key for raw querying Tasks address from the factory",
        "type": "array",
        "items": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint8",
              "minimum": 0.0
            },
            "maxItems": 2,
            "minItems": 2
          }
        ],
        "maxItems": 2,
        "minItems": 2
      },
      "min_active_agent_count": {
        "description": "Minimum agent count in active queue to be untouched by bad agent verifier",
        "type": [
          "integer",
          "null"
        ],
        "format": "uint16",
        "minimum": 0.0
      },
      "min_coin_for_agent_registration": {
        "description": "The required amount needed to actually execute a few tasks before withdraw profits. This helps make sure agent wont get stuck out the gate",
        "type": [
          "integer",
          "null"
        ],
        "format": "uint64",
        "minimum": 0.0
      },
      "min_tasks_per_agent": {
        "description": "The ratio used to calculate active agents/tasks. Example: \"3\", requires there are 4 tasks before letting in another agent to become active. (3 tasks for agent 1, 1 task for agent 2)",
        "type": [
          "integer",
          "null"
        ],
        "format": "uint64",
        "minimum": 0.0
      },
      "owner_addr": {
        "description": "Address of the contract owner, defaults to the sender",
        "type": [
          "string",
          "null"
        ]
      },
      "version": {
        "description": "CW2 Version provided by factory",
        "type": [
          "string",
          "null"
        ]
      }
    },
    "additionalProperties": false
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "description": "Execute messages for agent contract",
    "oneOf": [
      {
        "description": "Action registers new agent",
        "type": "object",
        "required": [
          "register_agent"
        ],
        "properties": {
          "register_agent": {
            "type": "object",
            "properties": {
              "payable_account_id": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Action for updating agents",
        "type": "object",
        "required": [
          "update_agent"
        ],
        "properties": {
          "update_agent": {
            "type": "object",
            "required": [
              "payable_account_id"
            ],
            "properties": {
              "payable_account_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Action moves agent from pending to active list",
        "type": "object",
        "required": [
          "check_in_agent"
        ],
        "properties": {
          "check_in_agent": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Actions for removing agent from the system",
        "type": "object",
        "required": [
          "unregister_agent"
        ],
        "properties": {
          "unregister_agent": {
            "type": "object",
            "properties": {
              "from_behind": {
                "type": [
                  "boolean",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Task contract will send message when task is created",
        "type": "object",
        "required": [
          "on_task_created"
        ],
        "properties": {
          "on_task_created": {
            "$ref": "#/definitions/AgentOnTaskCreated"
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Task contract will send message when task is completed",
        "type": "object",
        "required": [
          "on_task_completed"
        ],
        "properties": {
          "on_task_completed": {
            "$ref": "#/definitions/AgentOnTaskCompleted"
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Action for updating agent contract configuration",
        "type": "object",
        "required": [
          "update_config"
        ],
        "properties": {
          "update_config": {
            "type": "object",
            "required": [
              "config"
            ],
            "properties": {
              "config": {
                "$ref": "#/definitions/UpdateConfig"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Tick action will remove unactive agents periodically or do and any other internal cron tasks",
        "type": "object",
        "required": [
          "tick"
        ],
        "properties": {
          "tick": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      },
      "AgentOnTaskCompleted": {
        "type": "object",
        "required": [
          "agent_id",
          "is_block_slot_task"
        ],
        "properties": {
          "agent_id": {
            "$ref": "#/definitions/Addr"
          },
          "is_block_slot_task": {
            "type": "boolean"
          }
        },
        "additionalProperties": false
      },
      "AgentOnTaskCreated": {
        "type": "object",
        "additionalProperties": false
      },
      "UpdateConfig": {
        "description": "Updatable agents contract configuration",
        "type": "object",
        "properties": {
          "agent_nomination_duration": {
            "description": "Duration to be passed before next agent nomination",
            "type": [
              "integer",
              "null"
            ],
            "format": "uint16",
            "minimum": 0.0
          },
          "agents_eject_threshold": {
            "description": "How many slots an agent can miss before being removed from the active queue",
            "type": [
              "integer",
              "null"
            ],
            "format": "uint64",
            "minimum": 0.0
          },
          "croncat_factory_addr": {
            "description": "Address of the factory contract",
            "type": [
              "string",
              "null"
            ]
          },
          "croncat_manager_key": {
            "description": "Name of the key for raw querying Manager address from the factory",
            "type": [
              "array",
              "null"
            ],
            "items": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "integer",
                  "format": "uint8",
                  "minimum": 0.0
                },
                "maxItems": 2,
                "minItems": 2
              }
            ],
            "maxItems": 2,
            "minItems": 2
          },
          "croncat_tasks_key": {
            "description": "Name of the key for raw querying Tasks address from the factory",
            "type": [
              "array",
              "null"
            ],
            "items": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "integer",
                  "format": "uint8",
                  "minimum": 0.0
                },
                "maxItems": 2,
                "minItems": 2
              }
            ],
            "maxItems": 2,
            "minItems": 2
          },
          "min_active_agent_count": {
            "description": "Minimum agent count in active queue to be untouched by bad agent verifier",
            "type": [
              "integer",
              "null"
            ],
            "format": "uint16",
            "minimum": 0.0
          },
          "min_coins_for_agent_registration": {
            "description": "Minimum funds to be attached for agent registration",
            "type": [
              "integer",
              "null"
            ],
            "format": "uint64",
            "minimum": 0.0
          },
          "min_tasks_per_agent": {
            "description": "Minimum tasks count to be reached by agent before next agent nomination",
            "type": [
              "integer",
              "null"
            ],
            "format": "uint64",
            "minimum": 0.0
          },
          "owner_addr": {
            "description": "Contract owner address",
            "type": [
              "string",
              "null"
            ]
          },
          "paused": {
            "description": "Contract paused state, if contract is paused some action will not be available for execution",
            "type": [
              "boolean",
              "null"
            ]
          }
        },
        "additionalProperties": false
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "description": "Agent request response",
    "oneOf": [
      {
        "description": "Get an agent by specified account_id, returns AgentInfo if found",
        "type": "object",
        "required": [
          "get_agent"
        ],
        "properties": {
          "get_agent": {
            "type": "object",
            "required": [
              "account_id"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the id list of agents, pagination is supported",
        "type": "object",
        "required": [
          "get_agent_ids"
        ],
        "properties": {
          "get_agent_ids": {
            "type": "object",
            "properties": {
              "from_index": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              },
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the specified agent tasks",
        "type": "object",
        "required": [
          "get_agent_tasks"
        ],
        "properties": {
          "get_agent_tasks": {
            "type": "object",
            "required": [
              "account_id"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the agent contract configuration",
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Config",
      "description": "Contract configuration state",
      "type": "object",
      "required": [
        "agent_nomination_block_duration",
        "agents_eject_threshold",
        "croncat_factory_addr",
        "croncat_manager_key",
        "croncat_tasks_key",
        "min_active_agent_count",
        "min_coins_for_agent_registration",
        "min_tasks_per_agent",
        "owner_addr",
        "paused"
      ],
      "properties": {
        "agent_nomination_block_duration": {
          "description": "The duration a prospective agent has to nominate themselves. When a task is created such that a new agent can join, The agent at the zeroth index of the pending agent queue has this time to nominate The agent at the first index has twice this time to nominate (which would remove the former agent from the pending queue) Value is in seconds",
          "type": "integer",
          "format": "uint16",
          "minimum": 0.0
        },
        "agents_eject_threshold": {
          "description": "How many slots an agent can miss before being removed from the active queue",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "croncat_factory_addr": {
          "description": "Address of the factory contract",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "croncat_manager_key": {
          "description": "Name of the key for raw querying Manager address from the factory",
          "type": "array",
          "items": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "uint8",
                "minimum": 0.0
              },
              "maxItems": 2,
              "minItems": 2
            }
          ],
          "maxItems": 2,
          "minItems": 2
        },
        "croncat_tasks_key": {
          "description": "Name of the key for raw querying Tasks address from the factory",
          "type": "array",
          "items": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "uint8",
                "minimum": 0.0
              },
              "maxItems": 2,
              "minItems": 2
            }
          ],
          "maxItems": 2,
          "minItems": 2
        },
        "min_active_agent_count": {
          "description": "Minimum agent count in active queue to be untouched by bad agent verifier",
          "type": "integer",
          "format": "uint16",
          "minimum": 0.0
        },
        "min_coins_for_agent_registration": {
          "description": "Min coins that should be attached to register an agent",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "min_tasks_per_agent": {
          "description": "Agent management The minimum number of tasks per agent Example: 10 Explanation: For every 1 agent, 10 tasks per slot are available. NOTE: Caveat, when there are odd number of tasks or agents, the overflow will be available to first-come, first-serve. This doesn't negate the possibility of a failed txn from race case choosing winner inside a block. NOTE: The overflow will be adjusted to be handled by sweeper in next implementation.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "owner_addr": {
          "description": "Contract owner address",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "paused": {
          "description": "If contract was paused/unpaused",
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        }
      }
    },
    "get_agent": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AgentResponse",
      "description": "Agent response containing agent information",
      "type": "object",
      "properties": {
        "agent": {
          "description": "Agent data",
          "anyOf": [
            {
              "$ref": "#/definitions/AgentInfo"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "AgentInfo": {
          "description": "Agent data",
          "type": "object",
          "required": [
            "balance",
            "last_executed_slot",
            "payable_account_id",
            "register_start",
            "status"
          ],
          "properties": {
            "balance": {
              "description": "Agent balance",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "last_executed_slot": {
              "description": "Last executed slot number",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "payable_account_id": {
              "description": "Account where agent will move all his rewards",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "register_start": {
              "description": "Registration time",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "status": {
              "description": "Agent status",
              "allOf": [
                {
                  "$ref": "#/definitions/AgentStatus"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "AgentStatus": {
          "type": "string",
          "enum": [
            "active",
            "pending",
            "nominated"
          ]
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_agent_ids": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "GetAgentIdsResponse",
      "description": "Response containing active/pending agents",
      "type": "object",
      "required": [
        "active",
        "pending"
      ],
      "properties": {
        "active": {
          "description": "Active agent list",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Addr"
          }
        },
        "pending": {
          "description": "Pending agent list",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Addr"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        }
      }
    },
    "get_agent_tasks": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AgentTaskResponse",
      "description": "Agent task response for getting stats and task information",
      "type": "object",
      "required": [
        "stats"
      ],
      "properties": {
        "stats": {
          "description": "Agent tasks statistic information",
          "allOf": [
            {
              "$ref": "#/definitions/TaskStats"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "TaskStats": {
          "description": "Agent statistics data",
          "type": "object",
          "required": [
            "num_block_tasks",
            "num_cron_tasks"
          ],
          "properties": {
            "num_block_tasks": {
              "description": "Total block tasks for specified agent",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint64"
                }
              ]
            },
            "num_cron_tasks": {
              "description": "Total cron tasks for specified agent",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint64"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    }
  }
}
